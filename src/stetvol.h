/* Methods for computing the volume of a spherical tetrahedron on S3 */

#include <math.h>
#include <complex>
#include <vector>
#include <algorithm>

#include <Eigen/Dense>

double horner(double x, const double* c, int len)
{
    double p = 0.0;
    while (len--)
        p = p*x + c[len];
    return p;
}

template <int Nstart, int Nend, int N>
std::complex<double> horner(const std::complex<double>& z, const double (&coeffs)[N])
{
   static_assert(Nstart <= Nend && Nend < N && Nend >= 1, "invalid array bounds");

   const double r = z.real() + z.real();
   const double s = z.real() * z.real() + z.imag() * z.imag();
   double a = coeffs[Nend], b = coeffs[Nend - 1];

   for (int i = Nend - 2; i >= Nstart; --i) {
      const double t = a;
      a = b + r * a;
      b = coeffs[i] - s * t;
   }

   return std::complex<double>(z.real()*a + b, z.imag()*a);
}

double Li2(double x)
{
   constexpr double P[] = {
      1.0706105563309304277e+0,
     -4.5353562730201404017e+0,
      7.4819657596286408905e+0,
     -6.0516124315132409155e+0,
      2.4733515209909815443e+0,
     -4.6937565143754629578e-1,
      3.1608910440687221695e-2,
     -2.4630612614645039828e-4
   };
   constexpr double Q[] = {
      1.0000000000000000000e+0,
     -4.5355682121856044935e+0,
      8.1790029773247428573e+0,
     -7.4634190853767468810e+0,
      3.6245392503925290187e+0,
     -8.9936784740041174897e-1,
      9.8554565816757007266e-2,
     -3.2116618742475189569e-3
   };

   double y = 0, r = 0, s = 1;

   // transform to [0, 1/2)
   if (x < -1) {
      const double l = std::log(1.0 - x);
      y = 1/(1 - x);
       r = -M_PI*M_PI/6.0 + l*(0.5*l - std::log(-x));
      s = 1;
   } else if (x == -1) {
       return -M_PI*M_PI/12.0;
   } else if (x < 0) {
      const double l = std::log1p(-x);
       y = x/(x - 1.0);
      r = -0.5*l*l;
      s = -1.0;
   } else if (x == 0) {
      return 0;
   } else if (x < 0.5) {
      y = x;
      r = 0;
      s = 1;
   } else if (x < 1) {
      y = 1 - x;
       r = M_PI*M_PI/6.0 - std::log(x)*std::log(1.0 - x);
      s = -1;
   } else if (x == 1) {
       return M_PI*M_PI/6.0;
   } else if (x < 2) {
      const double l = std::log(x);
      y = 1.0 - 1.0/x;
       r = M_PI*M_PI/6.0 - l*(std::log(1.0 - 1.0/x) + 0.5*l);
      s = 1;
   } else {
      const double l = std::log(x);
      y = 1.0/x;
       r = M_PI*M_PI/3.0 - 0.5*l*l;
      s = -1.0;
   }

   const double z = y - 0.25;

   const double p = horner(z, P, sizeof(P)/sizeof(P[0]));
   const double q = horner(z, Q, sizeof(Q)/sizeof(Q[0]));

   return r + s*y*p/q;
}


std::complex<double> Li2(const std::complex<double>& z)
{
   // bf[1..N-1] are the even Bernoulli numbers / (2 n + 1)!
   // generated by: Table[BernoulliB[2 n]/(2 n + 1)!, {n, 1, 9}]
   constexpr double bf[10] = {
      - 1.0/4.0,
      + 1.0/36.0,
      - 1.0/3600.0,
      + 1.0/211680.0,
      - 1.0/10886400.0,
      + 1.0/526901760.0,
      - 4.0647616451442255e-11,
      + 8.9216910204564526e-13,
      - 1.9939295860721076e-14,
      + 4.5189800296199182e-16
   };

   const double nz = std::norm(z);

   // special cases
   if (z.imag() == 0) {
       if (z.real() <= 1.0) {
         return Li2(z.real()); //todo!
      }
      // z.re > 1
      return { Li2(z.real()), -M_PI*std::log(z.real()) };
   } else if (nz < std::numeric_limits<double>::epsilon()) {
      return z;
   }

   std::complex<double> cy(0.0, 0.0), cz(0.0, 0.0);
   double sgn = 1;

   // transformation to |z|<1, Re(z)<=0.5
   if (z.real() <= 0.5) {
       if (nz > 1.0) {
         const std::complex<double> lz = std::log(-z);
          cy = -0.5*lz*lz - M_PI*M_PI/6.0;
          cz = -std::log(1.0 - 1.0 / z);
          sgn = -1.0;
      } else { // nz <= 1
         cy = 0;
          cz = -std::log(std::complex<double>(1.0,0.0) - z);
          sgn = 1.0;
      }
   } else { // z.re > 0.5
       if (nz <= 2.0*z.real()) {
         cz = -std::log(z);
           cy = cz*std::log(std::complex<double>(1.0,0.0) - z) + M_PI*M_PI/6.0;
           sgn = -1.0;
      } else { // nz > 2*z.re
         const std::complex<double> lz = std::log(-z);
          cy = -0.5*lz*lz - M_PI*M_PI/6.0;
         cz = -std::log(std::complex<double>(1.0,0.0) - 1.0 / z);
          sgn = -1.0;
      }
   }

   const std::complex<double> cz2(cz*cz);

   return sgn * (cz + cz2*(bf[0] + cz*horner<1, 9>(cz2, bf))) + cy;
}

Eigen::Matrix<double,6,1> dihedrals(const Eigen::Matrix4d& P)
{
    Eigen::Matrix4d N = P.inverse();
    N.rowwise().normalize();
    Eigen::Matrix4d C = -N*N.transpose();
    Eigen::VectorXd d(6);
    d[0] = std::acos(C(2,3));
    d[1] = std::acos(C(0,2));
    d[2] = std::acos(C(0,3));
    d[3] = std::acos(C(0,1));
    d[4] = std::acos(C(1,3));
    d[5] = std::acos(C(1,2));
    return d;
}


std::complex<double> L(const Eigen::Matrix<std::complex<double>,6,1>& a, const std::complex<double>& z)
{
    std::complex<double> l = Li2(z);
//    std::cerr << "Li2( " << z << " ) = " << l << std::endl;
    l += Li2(z/(a[0]*a[1]*a[3]*a[4]));
    l += Li2(z/(a[0]*a[2]*a[3]*a[5]));
    l += Li2(z/(a[1]*a[2]*a[4]*a[5]));
    l -= Li2(-z/(a[0]*a[1]*a[2]));
    l -= Li2(-z/(a[0]*a[4]*a[5]));
    l -= Li2(-z/(a[1]*a[3]*a[5]));
    l -= Li2(-z/(a[2]*a[3]*a[4]));
    for (int j = 0; j < 3; j++)
        l += std::log(a[j])*std::log(a[j+3]);
    return l/2.0;
}


double vol(const Eigen::Matrix<double,6,1>& d)
{
    Eigen::Matrix<std::complex<double>,6,1> a(6);
    for (int j = 0; j < 6; j++) a[j] = std::exp(std::complex<double>(0.0,d[j]));
    
    std::complex<double> a03 = a[0]*a[3];
    std::complex<double> a14 = a[1]*a[4];
    std::complex<double> a25 = a[2]*a[5];
    std::complex<double> aa = a03*a14*a25;
    
    std::complex<double> q0 = a03 + a14 + a25 + aa +
        a[0]*a[1]*a[5] + a[0]*a[2]*a[4] + a[1]*a[2]*a[3] + a[3]*a[4]*a[5];
    std::complex<double> q1 = -( (a[0]-1.0/a[0])*(a[3]-1.0/a[3]) + (a[1]-1.0/a[1])*(a[4]-1.0/a[4]) + (a[2]-1.0/a[2])*(a[5]-1.0/a[5]) );
    std::complex<double> q2 = 1.0/a03+1.0/a14+1.0/a25+1.0/aa + 1.0/(a[0]*a[1]*a[5]) + 1.0/(a[0]*a[2]*a[4]) + 1.0/(a[1]*a[2]*a[3]) + 1.0/(a[3]*a[4]*a[5]);
    std::complex<double> z0 = (-q1+std::sqrt(q1*q1-4.0*q0*q2))/(2.0*q2);
    
    std::complex<double> l = Li2(z0) + Li2(z0/(a03*a14)) + Li2(z0/(a03*a25)) + Li2(z0/(a14*a25));
    l -= Li2(-z0/(a[0]*a[1]*a[2])) + Li2(-z0/(a[0]*a[4]*a[5])) + Li2(-z0/(a[1]*a[3]*a[5])) + Li2(-z0/(a[2]*a[3]*a[4]));
    l += std::log(a[0])*std::log(a[3]) + std::log(a[1])*std::log(a[4]) + std::log(a[2])*std::log(a[5]);
                                                                         
    double v = -0.5*l.real() + M_PI*(std::arg(-q2)+0.5*d.sum()) - 1.5*(M_PI*M_PI);
    return std::fmod(v,2.0*M_PI*M_PI);
}

